/// This file is automatically generated by `cargo-pkg-info-struct-builder`.
///
/// It contains a struct `CargoPkgInfo` that provides access to package metadata
/// set by Cargo at compile time, including versioning, authors, license information,
/// and build details. The values are obtained from environment variables defined
/// in the Cargo.toml file and passed during the build process.
///
/// For more information, see: <https://doc.rust-lang.org/cargo/reference/environment-variables.html>

const NO_ENV_FALLBACK: &str = "N/A";

pub struct CargoPkgInfo {}

impl CargoPkgInfo {
    /// Returns the application name.
    ///
    /// # Example
    /// ```
    /// use cargo_pkg_info_struct::CargoPkgInfo;
    /// let info = CargoPkgInfo::new();
    /// assert!(!info.app_name().is_empty());
    /// ```
    #[allow(dead_code)]
    pub fn pkg_name() -> &'static str {
        option_env!("CARGO_PKG_NAME")
            .unwrap_or(NO_ENV_FALLBACK)
            .into()
    }

    /// Returns the crate name.
    ///
    /// # Example
    /// ```
    /// use cargo_pkg_info_struct::CargoPkgInfo;
    /// let info = CargoPkgInfo::new();
    /// assert!(!info.crate_name().is_empty());
    /// ```
    #[allow(dead_code)]
    pub fn crate_name() -> &'static str {
        option_env!("CARGO_CRATE_NAME")
            .unwrap_or(NO_ENV_FALLBACK)
            .into()
    }

    /// Returns the full application version.
    ///
    /// # Example
    /// ```
    /// use cargo_pkg_info_struct::CargoPkgInfo;
    /// let info = CargoPkgInfo::new();
    /// assert!(!info.app_version().is_empty());
    /// ```
    #[allow(dead_code)]
    pub fn app_version() -> &'static str {
        option_env!("CARGO_PKG_VERSION")
            .unwrap_or(NO_ENV_FALLBACK)
            .into()
    }

    /// Returns the major version of the application.
    ///
    /// # Example
    /// ```
    /// use cargo_pkg_info_struct::CargoPkgInfo;
    /// let info = CargoPkgInfo::new();
    /// assert!(!info.version_major().is_empty());
    /// ```
    #[allow(dead_code)]
    pub fn version_major() -> &'static str {
        option_env!("CARGO_PKG_VERSION_MAJOR")
            .unwrap_or(NO_ENV_FALLBACK)
            .into()
    }

    /// Returns the minor version of the application.
    ///
    /// # Example
    /// ```
    /// use cargo_pkg_info_struct::CargoPkgInfo;
    /// let info = CargoPkgInfo::new();
    /// assert!(!info.version_minor().is_empty());
    /// ```
    #[allow(dead_code)]
    pub fn version_minor() -> &'static str {
        option_env!("CARGO_PKG_VERSION_MINOR")
            .unwrap_or(NO_ENV_FALLBACK)
            .into()
    }

    /// Returns the patch version of the application.
    ///
    /// # Example
    /// ```
    /// use cargo_pkg_info_struct::CargoPkgInfo;
    /// let info = CargoPkgInfo::new();
    /// assert!(!info.version_patch().is_empty());
    /// ```
    #[allow(dead_code)]
    pub fn version_patch() -> &'static str {
        option_env!("CARGO_PKG_VERSION_PATCH")
            .unwrap_or(NO_ENV_FALLBACK)
            .into()
    }

    /// Returns the pre-release version of the application.
    ///
    /// # Example
    /// ```
    /// use cargo_pkg_info_struct::CargoPkgInfo;
    /// let info = CargoPkgInfo::new();
    /// assert!(info.version_pre().len() >= 0);
    /// ```
    #[allow(dead_code)]
    pub fn version_pre() -> &'static str {
        option_env!("CARGO_PKG_VERSION_PRE")
            .unwrap_or(NO_ENV_FALLBACK)
            .into()
    }

    /// Returns the authors of the package.
    ///
    /// # Example
    /// ```
    /// use cargo_pkg_info_struct::CargoPkgInfo;
    /// let info = CargoPkgInfo::new();
    /// assert!(!info.authors().is_empty());
    /// ```
    #[allow(dead_code)]
    pub fn authors() -> &'static str {
        option_env!("CARGO_PKG_AUTHORS")
            .unwrap_or(NO_ENV_FALLBACK)
            .into()
    }

    /// Returns the description of the package.
    ///
    /// # Example
    /// ```
    /// use cargo_pkg_info_struct::CargoPkgInfo;
    /// let info = CargoPkgInfo::new();
    /// assert!(!info.description().is_empty());
    /// ```
    #[allow(dead_code)]
    pub fn description() -> &'static str {
        option_env!("CARGO_PKG_DESCRIPTION")
            .unwrap_or(NO_ENV_FALLBACK)
            .into()
    }

    /// Returns the homepage URL of the package.
    ///
    /// # Example
    /// ```
    /// use cargo_pkg_info_struct::CargoPkgInfo;
    /// let info = CargoPkgInfo::new();
    /// assert!(!info.homepage().is_empty());
    /// ```
    #[allow(dead_code)]
    pub fn homepage() -> &'static str {
        option_env!("CARGO_PKG_HOMEPAGE")
            .unwrap_or(NO_ENV_FALLBACK)
            .into()
    }

    /// Returns the repository URL of the package.
    ///
    /// # Example
    /// ```
    /// use cargo_pkg_info_struct::CargoPkgInfo;
    /// let info = CargoPkgInfo::new();
    /// assert!(!info.repository().is_empty());
    /// ```
    #[allow(dead_code)]
    pub fn repository() -> &'static str {
        option_env!("CARGO_PKG_REPOSITORY")
            .unwrap_or(NO_ENV_FALLBACK)
            .into()
    }

    /// Returns the license type of the package.
    ///
    /// # Example
    /// ```
    /// use cargo_pkg_info_struct::CargoPkgInfo;
    /// let info = CargoPkgInfo::new();
    /// assert!(!info.license().is_empty());
    /// ```
    #[allow(dead_code)]
    pub fn license() -> &'static str {
        option_env!("CARGO_PKG_LICENSE")
            .unwrap_or(NO_ENV_FALLBACK)
            .into()
    }

    /// Returns the contents of the license file (embedded at build time).
    ///
    /// # Example
    /// ```
    /// use cargo_pkg_info_struct::CargoPkgInfo;
    /// let info = CargoPkgInfo::new();
    /// assert!(info.license_content().len() > 0);
    /// ```
    #[allow(dead_code)]
    pub fn license_content() -> &'static str {
        option_env!("CARGO_PKG_LICENSE_CONTENT")
            .unwrap_or(NO_ENV_FALLBACK)
            .into()
    }

    /// Returns the Rust version required by the package.
    ///
    /// # Example
    /// ```
    /// use cargo_pkg_info_struct::CargoPkgInfo;
    /// let info = CargoPkgInfo::new();
    /// assert!(!info.rust_version().is_empty());
    /// ```
    #[allow(dead_code)]
    pub fn rust_version() -> &'static str {
        option_env!("CARGO_PKG_RUST_VERSION")
            .unwrap_or(NO_ENV_FALLBACK)
            .into()
    }

    /// Returns the path to the README file.
    ///
    /// # Example
    /// ```
    /// use cargo_pkg_info_struct::CargoPkgInfo;
    /// let info = CargoPkgInfo::new();
    /// assert!(!info.readme_path().is_empty());
    /// ```
    #[allow(dead_code)]
    pub fn readme_path() -> &'static str {
        option_env!("CARGO_PKG_README")
            .unwrap_or(NO_ENV_FALLBACK)
            .into()
    }

    /// Returns the build target (architecture/platform).
    ///
    /// # Example
    /// ```
    /// use cargo_pkg_info_struct::CargoPkgInfo;
    /// let info = CargoPkgInfo::new();
    /// assert!(!info.build_target().is_empty());
    /// ```
    #[allow(dead_code)]
    pub fn build_target() -> &'static str {
        option_env!("BUILD_TARGET")
            .unwrap_or(NO_ENV_FALLBACK)
            .into()
    }

    /// Returns the UTC build time as an `Option<u64>`.
    ///
    /// This method retrieves the build time, which was set at compile time via
    /// the `BUILD_TIME_UTC` environment variable. The build time is represented
    /// as a `u64` timestamp (in seconds since the Unix epoch). If the environment
    /// variable is not set, it returns `None`.
    ///
    /// # Example
    /// ```
    /// use cargo_pkg_info_struct::CargoPkgInfo;
    /// let info = CargoPkgInfo::new();
    /// match info.build_time_utc() {
    ///     Some(build_time) => {
    ///         println!("Build time: {}", build_time);
    ///     }
    ///     None => {
    ///         println!("Build time not available");
    ///     }
    /// }
    /// ```
    #[allow(dead_code)]
    pub fn build_time_utc() -> Option<u64> {
        option_env!("BUILD_TIME_UTC").and_then(|s| s.parse::<u64>().ok())
    }
}
